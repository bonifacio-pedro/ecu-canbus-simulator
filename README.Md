# üöó CAN Bus ECU Simulator

![CAN Bus](https://img.shields.io/badge/Protocol-CAN%20Bus-blue)
![Language](https://img.shields.io/badge/Language-C99-orange)
![Status](https://img.shields.io/badge/Status-Production%20Ready-success)

![TelemetrySim](ecu_telemetry_analysis.png)

> **Professional-grade automotive ECU simulator implementing ISO 11898 CAN protocol with multi-frame arbitration, realistic physics, and diagnostic system.**

## üéØ Features

- ‚úÖ **Real CAN Bus Implementation**: Message arbitration, priority handling, broadcast
- ‚úÖ **3 CAN Frames**: Powertrain (0x100), Dynamics (0x200), Sensors (0x300)
- ‚úÖ **Realistic Physics**: Engine, throttle, brake, temperature simulation
- ‚úÖ **Diagnostic System**: Error codes (DTC-like), multi-sensor monitoring
- ‚úÖ **Telemetry Export**: CSV logging for post-analysis
- ‚úÖ **Python Visualization**: Automated plotting and analysis
  
## üîí Safety Features (NEW!)1. XOR Checksum Validation
1. XOR Checksum Validation
    Every CAN frame includes an XOR checksum to detect data corruption:
    ```c
    uint8_t can_checksum(const uint8_t *data, uint8_t len) {
        uint8_t cs = 0;
        for (uint8_t i = 0; i < len; i++) {
            cs ^= data[i];
        }
        return cs;
    }
    ``` 
    Protection against:
- ‚úÖ Bit flips during transmission
- ‚úÖ Electrical noise interference
- ‚úÖ Hardware failures

2. Sequence Counter Validation
    Each frame type has an independent rolling counter (0-255):
    ```c
    static uint8_t seq_powertrain = 0;  // Increments with each transmission
    static uint8_t last_seq_powertrain = 0xFF;  // Tracks expected sequence
    ```
Detection of:
- ‚úÖ Lost messages (gap in sequence)
- ‚úÖ Duplicated messages (same sequence twice)
- ‚úÖ Out-of-order messages (sequence jump)

3. Error Code System
When validation fails, specific error flags are set:
```c
typedef enum {
    ECU_ERR_NONE          = 0x00,
    ECU_ERR_CAN_CHECKSUM  = 0x01,
    ECU_ERR_CAN_SEQ       = 0x02,
    ECU_ERR_CAN_TIMEOUT   = 0x04,
    ECU_ERR_OVER_RPM      = 0x08,
    ECU_ERR_OVER_TEMP     = 0x10,
} ECUErrorCode;
```
## üèóÔ∏è Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         CAN BUS SIMULATOR                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

ECU_TX (Transmitter)
  ‚îÇ
  ‚îú‚îÄ‚Üí encode_powertrain_frame()  ‚Üí CAN ID 0x100
  ‚îÇ    ‚îú‚îÄ Data encoding
  ‚îÇ    ‚îú‚îÄ Sequence counter++
  ‚îÇ    ‚îî‚îÄ XOR checksum
  ‚îÇ
  ‚îú‚îÄ‚Üí encode_dynamics_frame()    ‚Üí CAN ID 0x200
  ‚îÇ    ‚îú‚îÄ Data encoding
  ‚îÇ    ‚îú‚îÄ Sequence counter++
  ‚îÇ    ‚îî‚îÄ XOR checksum
  ‚îÇ
  ‚îî‚îÄ‚Üí encode_sensors_frame()     ‚Üí CAN ID 0x300
       ‚îú‚îÄ Data encoding
       ‚îú‚îÄ Sequence counter++
       ‚îî‚îÄ XOR checksum
                ‚îÇ
                ‚Üì
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ          CAN BUS                   ‚îÇ
   ‚îÇ  ‚Ä¢ send()                          ‚îÇ
   ‚îÇ  ‚Ä¢ arbitrate() ‚Üê üî• (by priority)  ‚îÇ
   ‚îÇ  ‚Ä¢ deliver()                       ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ
                ‚Üì
ECU_RX (Receiver)
  ‚îÇ
  ‚îú‚îÄ‚Üí decode_powertrain_frame()
  ‚îÇ    ‚îú‚îÄ ‚úì Checksum validation
  ‚îÇ    ‚îú‚îÄ ‚úì Sequence validation
  ‚îÇ    ‚îî‚îÄ Data extraction
  ‚îÇ
  ‚îú‚îÄ‚Üí decode_dynamics_frame()
  ‚îÇ    ‚îú‚îÄ ‚úì Checksum validation
  ‚îÇ    ‚îú‚îÄ ‚úì Sequence validation
  ‚îÇ    ‚îî‚îÄ Data extraction
  ‚îÇ
  ‚îî‚îÄ‚Üí decode_sensors_frame()
       ‚îú‚îÄ ‚úì Checksum validation
       ‚îú‚îÄ ‚úì Sequence validation
       ‚îî‚îÄ Data extraction
```

## üöÄ Quick Start
### Build
```bash
make
```
### Run
```bash
make run
```
### Analyze
```bash
jupyter notebook analyze_telemetry.ipynb
```

## üìä CAN Frame Structure

### Frame 1: Powertrain (ID 0x100, DLC 4)
| Byte | Data | Format | Range |Notes
|------|------|--------|-------|----
| 0-1  | RPM  | uint16_t (Big-Endian) | 0-8000 |MSB first
| 2    | Gear | uint8_t | 0-6 |Automatic calculation
| 3    | Flags | Bit 1: Engine On<br>Bit 0: Brake | 0x00-0x03 |Bitwise packed
|4|Sequence|uint8_t|0-255|Rolling counter
|5|Checksum|uint8_t|0-255|XOR of bytes 0-4

### Frame 2: Dynamics (ID 0x200, DLC 4)
| Byte | Data | Format | Range |Notes
|------|------|--------|-------| ---
| 0 | Speed | uint8_t | 0-250 km/h |From RPM calculation
| 1 | Brake Pressure | uint8_t | 0-100% |Gradual increase
| 2 | Throttle | uint8_t | 0-100% |Input simulation
|3|Reserved|uint8_t| -|Future use
|4|Sequence|uint8_t|0-255|Rolling counter
|5|Checksum|uint8_t|0-255|XOR of bytes 0-4

### Frame 3: Sensors (ID 0x300, DLC 5)
| Byte | Data | Format | Range |Notes
|------|------|--------|-------|---
| 0 | Engine Temp | uint8_t | 0-255¬∞C |Physics simulation
| 1 | Oil Pressure | uint8_t | 0-100 bar |RPM-based
| 2 | Battery Voltage | uint8_t | 0-255 (√ó0.1V) |12.4V = 124
| 3 | Error Code | uint8_t | DTC codes |Multi-bit flags
| 3 | Error Code | uint8_t | DTC codes |Multi-bit flags
| 4 | Reserved |  | - |Future use
|5|Sequence|uint8_t|0-255|Rolling counter
|6|Checksum|uint8_t|0-255|XOR of bytes 0-4



## üìà Sample Output
```
=== ACTUAL STATE ==
RPM: 4523
SPEED: 145
THROTTLE: 78
BRAKE: 0
GEAR: 4
ENGINE TEMP: 92
OIL PRESSURE: 65
BATTERY_VOLTAGE: 140
ERROR CODE: 0
===================
```


### With CAN Errors:
```
=== ACTUAL STATE ==
RPM: 4523
SPEED: 145
THROTTLE: 78
BRAKE: 0
GEAR: 4
ENGINE TEMP: 92
OIL PRESSURE: 65
BATTERY_VOLTAGE: 140
ERROR CODE: 0x03  ‚Üê Checksum (0x01) + Sequence (0x02) errors!
‚ö†Ô∏è  CAN CHECKSUM ERROR DETECTED!
‚ö†Ô∏è  CAN SEQUENCE ERROR DETECTED!
===================
```


## üéØ Technical Highlights

**For Automotive Engineers:**
- ISO 11898 compliant message structure
- Multi-priority arbitration system
- Realistic sensor simulation with physics
- DTC-like error code system

**For Software Engineers:**
- Clean architecture (CAN protocol ‚Üî ECU logic separation)
- Modular design (easy to add new frames)
- Production-quality code (error handling, documentation)
- Multi-language stack (C + Python)

## üìö Documentation

- [CAN.md](docs/CAN.md) - Complete CAN protocol explanation
- [analyze_telemetry.ipynb](analyze_telemetry.ipynb) - Data analysis notebook
## üõ†Ô∏è Technologies

- **C99**: Core simulation
- **Python 3**: Data analysis
- **Jupyter**: Visualization
- **Make**: Build system

## üë§ Author

**Pedro Henrique Bonif√°cio da Rosa**  
Computer Engineering Student @ UNISINOS  
Focused on: Automotive Embedded Systems | CAN Protocol | ECU Development

üìß pedrorosa.rb@gmail.com  
üíº [LinkedIn](https://www.linkedin.com/in/pedro-bonif√°cio-9869a9263/)  

## üìÑ License

MIT License - Feel free to use for learning and research!

---

‚≠ê **If this project helped you understand CAN Bus, give it a star!**

*Built with precision for the automotive software community* üöóüí®